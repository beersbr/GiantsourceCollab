<!doctype html>
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
    <title></title>
<style>
canvas{ background-color:black; }
</style>
    <script src="http://code.jquery.com/jquery-2.0.3.min.js"></script>
    <script src="keyboard.js"></script>
    <script src="tools.js"></script>
    <script src="list.js"></script>
    <script src="vector.js"></script>

<script>
	
	var gameConfig = {
		"settings": {
			"title":"Stupid Zombies",
			"width":800,
			"height":600,
            "quadrant": {

                "w":400,
                "h":600

            }	

		},
		"resources": {
            "gameFx" : {


                "gameover" : "gameover.ogg"

            },
			"characters": {
				"player1":{
					"name": "Phillip",
					"sprite": {

                        "src": "player1Sprite.png",
                        "w":41,
                        "h":101


                    },
                    "spawn" : {

                        "x":400,
                        "y":300

                    },

					"type":"Player",
                    "fx": {"shoot":"shotgun.ogg"}
				},
				"player2":{
					"name": "Jorge",
					"sprite": {

                        "src": "player2Sprite.png",
                        "w":62,
                        "h":101


                    },
                    "spawn" : {

                        "x":400,
                        "y":300

                    },

                    "type":"Player",
                    "fx": {"shoot":"shotgun.ogg"}


				},
				"enemy1":{
					"name": "Office Zombie",
					"sprite": {

                        "src": "zombieSprite.png",
                        "w":70,
                        "h":70


                    },
					"type":"Enemy",
                    "follow":false,
                    "speed" : "random",
                    "fx" : {
                        "spawn": "zombieRising.ogg"
                    }	

				},
				"enemy2": {
					"name": "Girl Zombie",
					"sprite": {

                        "src": "zombie2Sprite.png",
                        "w":70,
                        "h":69
                    },

					"type":"Enemy",
                    "follow":true,
                    "speed" : 200,
                    "fx" : {
                        "spawn": "brains.ogg"
                    }	
				}
			},
			"levels": {
				"1" :{
					"name":"Swamp",
					"src":"swamp.jpg"	
				}
			},
			"screens": {
				
				"welcome": {
					"name":"Welcome",
					"src":"welcome.jpg"	
				},
				"gameover": {
					"name":"Game Over",
					"src":"gameover.jpg"	
					
				}	
			}
		}
	}
	

 
    RESOURCES = (function(){
        var resources = {};

        var resourcesCount = 0,
            resourcesLoaded = 0,
            resourcesAreLoaded = false,
            resourceCache = {};

        resources.TYPES = {};
        resources.TYPES.AUDIO = 1;
        resources.TYPES.IMAGE = 2;

        function onResourceLoaded(event, type, key){
            resourcesLoaded += 1;

            if (type == "audio") {
                $(resourceCache[key]).unbind("loadeddata");
                resourceCache[key] = new audio(resourceCache[key]);
            }

            return true;
        }

        // this is just an audio tag wrapper that creates a bunch of the same audio tag 
        // so we can play more than one instance of that sound at a time... actually we can 
        // play maxChannels many :D
        function audio(audio) {
            this.maxChannels = 20;
            this.channels = [];

            this.audio = audio;
            this.currentChannel = 0;
            this.volume = 1;

            for (var i = 0; i < this.maxChannels; i++) {
                this.channels[i] = new Audio();
                this.preload = true;
                this.channels[i].src = this.audio.src;
            }

            this.play = function () {

                this.channels[this.currentChannel].load();
                this.channels[this.currentChannel].volume = this.volume;
                this.channels[this.currentChannel].play();
                this.currentChannel = (this.currentChannel + 1) % this.maxChannels;
            }

            this.load = function () { }
        }

        resources.isLoaded = function(){
            if(resourcesCount == resourcesLoaded){
                resourcesAreLoaded = true;
            }
            return resourcesAreLoaded;
        }

        resources.markResource = function(resourceKey, resourcePath, resourceType){
            var object = null;

            switch(resourceType){
                case resources.TYPES.IMAGE: 
                    resourcesCount += 1;
                    object = new Image();
                    object.src = resourcePath;
                    resourceCache[resourceKey] = object;
                    object.onload = onResourceLoaded;

                    break;
                case resources.TYPES.AUDIO:
                    resourcesCount += 1;
                    object = new Audio();
                    object.preload = true;
                    
                    resourceCache[resourceKey] = object;
                    $(object).on("loadeddata", function (event) { onResourceLoaded(event, "audio", resourceKey); });
                    object.src = resourcePath;
                    object.load();
                    o = object;
                    break;
            }
        }

        resources.get = function(resourceKey){
            if(!resourcesAreLoaded)
                throw "Resources aren't loaded yet :(";

            return resourceCache[resourceKey];
        }

        return resources;
    })();

    function Sprite(args){
        if(args == undefined) args = {}

        this.frameWidth = args.frameWidth || -1;
        this.frameHeight = args.frameHeight || -1;
        this.image = args.image || null;
        this.frameTime = args.frameTime || -1; //1000/60 * 4;

        // error handling => didnt pass in frame width and height and image
        if(this.frameWidth < 0) {
            // Some error
        }
        if(this.frameHeight < 0) {
            // Some error
        }
        if(this.frameTime < 0) {
            // Some error
        }
        if(!this.image) {
            // Some error
        }
        //console.log(args);
        this.imageWidth = this.image.width;
        this.imageHeight = this.image.height;

        this.framesCount = this.imageWidth / this.frameWidth;
        this.currentFrame = 0;
		//console.log('TOTAL FRAMES = '+ this.framesCount);
        this.currentFrameTime = 0;
        this.currentFrameElapsedTime = 0;
        this.currentFrameImage = document.createElement("canvas");
        this.currentFrameContext = this.currentFrameImage.getContext("2d");
        this.currentFrameImage.width = this.frameWidth;
        this.currentFrameImage.height = this.frameHeight;

        this.render = function(){
            this.currentFrameContext.clearRect(0, 0, this.frameWidth, this.frameHeight);
            this.currentFrameContext.drawImage(this.image, this.frameWidth*this.currentFrame, 0, this.frameWidth, this.frameHeight, 0, 0, this.frameWidth, this.frameHeight);
		
            if(this.currentFrameElapsedTime < this.frameTime){
                this.currentFrameElapsedTime += GAME.elapsedTime;
            }
            else {
                this.currentFrame = (this.currentFrame + 1) % this.framesCount;
                this.currentFrameElapsedTime = (this.currentFrameElapsedTime - this.frameTime);
            }

            return this.currentFrameImage;
        }
    }



    function Entity(args){
        if(args == undefined) args = {};

        var x = args.x || 0;
        var y = args.y || 0;
        var w = args.w || 1;
        var h = args.h || 1;

        this.position = new VECTOR.Vector(x, y);
        this.size = new VECTOR.Vector(w, h);
        this.velocity = new VECTOR.Vector();

        this.image = null;

        this.update = function (elapsedTime) { throw "NOT IMPLEMENTED"; };
        this.draw = function (renderContext) { throw "NOT IMPLEMENTED"; };

        this.toRect = function () {
            var hw = this.size.x / 2;
            var hh = this.size.y / 2;
            return (new Rect(this.position.x - hw, this.position.y - hh, this.size.x, this.size.y));
        }
    }
	
	function Enemy(args) {
             if(args == undefined) args = {};
       		 InheritFrom(this, Entity, args);
			this.image = RESOURCES.get(gameConfig.resources.characters[args.name].name);
			this.sprite = new Sprite({ image: this.image, frameTime: (1000/60 * 8), frameHeight: args.h, frameWidth: args.w});
			//console.log(args);
           
            var spawnAudio = RESOURCES.get(args.name+'Spawn');
            spawnAudio.volume = 0.3;
            spawnAudio.play();
            this.currentQuadrant = null;
			
			var hitPoints = 1;
			var rand = RandomInt(3);
            this.enemyName = args.name;
            this.enemySpeed = (gameConfig.resources.characters[this.enemyName].speed == 'random' ? 100 + RandomInt(100) : gameConfig.resources.characters[this.enemyName].speed);
      	    
            switch (rand) {
                // Top
                case 0:
                    this.position.x = RandomInt(GAME.width);
                    this.position.y = 0;
                    this.velocity.y = this.enemySpeed
                    break;
                    // Left
                case 1:
                    this.position.x = 0;
                    this.position.y = RandomInt(GAME.height);
                    this.velocity.x = this.enemySpeed
                    break;
                    // Bottom
                case 2:
                    this.position.x = RandomInt(GAME.width);
                    this.position.y = GAME.height;
                    this.velocity.y = -this.enemySpeed;
                    break;
                    // Right
                case 3:
                    this.position.x = GAME.width;
                    this.position.y = RandomInt(GAME.height);
                    this.velocity.x = -this.enemySpeed;
                    break;

            } // end switch

             this.followPlayer = function () {
					
                    var moveEnemy = VECTOR.subtract(GAME.player.position,  this.position);
                  
                    this.velocity = VECTOR.unit(moveEnemy);
                    
                   
            }


            this.draw = function (rc) {

                if (gameConfig.resources.characters[this.enemyName].follow) this.followPlayer();

               
                var r = this.toRect();
				rc.save();
           	 	var image = this.sprite.render();
				rc.drawImage(image, r.x, r.y, r.w, r.h);
				rc.restore();
            }

           

            this.update = function () {
                
                if (gameConfig.resources.characters[this.enemyName].follow)this.followPlayer();
                	
                var moveSpeed = VECTOR.multiplyScalar(this.velocity, (GAME.elapsedTime / 1000));

               		 //var moveSpeedx = this.velocity.x * (GAME.elapsedTime / 1000);
                	//var moveSpeedy = this.velocity.y * (GAME.elapsedTime / 1000);

                 this.position = VECTOR.add(this.position, moveSpeed);
   
                if (this.position.x < 0 || this.position.x > GAME.width ||
                    this.position.y < 0 || this.position.y > GAME.height)
                    return false;

                return true;
            }
    }


    function Bullet(args) {
        if(args == undefined) args = {};
        InheritFrom(this, Entity, args);

        this.size = new VECTOR.Vector(args.direction.x * 25 || 5, args.direction.y * 25 || 5);

        this.bulletSpeed = 150;

        this.direction = args.direction;
        this.velocity = VECTOR.multiplyScalar(args.direction, this.bulletSpeed)
        this.position = args.position;
             
        this.draw = function (rc) {

            var r = this.toRect();
            rc.save();
            rc.fillStyle = "rgb(0, 0, 255)";
            rc.fillRect(r.x, r.y, r.w, r.h);
            rc.restore();
        }

        this.update = function () {
            var v = VECTOR.multiplyScalar(this.velocity, GAME.elapsedTime / 1000);
            this.position = VECTOR.add(this.position, v);
            return true;
        }
    }

    function Player(args){
        if(args == undefined) args = {};
        InheritFrom(this, Entity, args);
        //console.log(args);
        this.image = RESOURCES.get(gameConfig.resources.characters[args.selectedPlayer].name);
        
        this.sprite = new Sprite({ image: this.image, frameTime: (1000/60 * 8), frameHeight: gameConfig.resources.characters[args.selectedPlayer].sprite.h, frameWidth: gameConfig.resources.characters[args.selectedPlayer].sprite.w});


        var moveSpeed = 150, // pixels/second
            sprintSpeed = 300,
            isSprinting = false,
            sprintInterval = 2000, 
            sprintTime = 500,
            sprintLength = 0,
            lastSprintTime = -1,
            sprintElapsedTime = 0,
            nonSprintElapsedTime = 0,
            runBarPercent = 100;

        var isShooting = false,
            shootInterval = 500, // in milliseconds
            shootDirection = null,
            lastShotTime = -1,
            lastShotElapsedTime = -1;

            this.zombiesKilled = 0;
      
        this.update = function(){

            var frameMoveSpeed = moveSpeed;

            if (GAME.Keyboard.keyIsDown("shift")) {
                if(! isSprinting){
                    nonSprintElapsedTime += GAME.elapsedTime;

                    if(nonSprintElapsedTime > sprintInterval){
                        frameMoveSpeed = sprintSpeed;
                        isSprinting = true;
                        lastSprintTime = +(new Date());
                        nonSprintElapsedTime = 0;
                        sprintLength += GAME.elapsedTime;
                    }
                }
                else{
                    sprintElapsedTime += GAME.elapsedTime;
                    if(sprintElapsedTime > sprintTime){
                        isSprinting = false;
                        sprintElapsedTime = 0;
                    }
                    else{
                        frameMoveSpeed = sprintSpeed;
                        sprintLength += GAME.elapsedTime;
                    }
                }
            }
            else { 
                // Not sprinting
                isSprinting = false;
                sprintElapsedTime = 0;
                nonSprintElapsedTime += GAME.elapsedTime;            
                if(nonSprintElapsedTime > sprintInterval) sprintLength = 0;
            } 

            // Show run bar
            this.runBar();
            
            // Update character movement

            if (GAME.Keyboard.keyIsDown("a")) {
                this.velocity.x -= frameMoveSpeed;
            }
            if (GAME.Keyboard.keyIsDown("d")) {
                this.velocity.x += frameMoveSpeed;
            }
            if (GAME.Keyboard.keyIsDown("w")) {
                this.velocity.y -= frameMoveSpeed;
            }
            if (GAME.Keyboard.keyIsDown("s")) {
                this.velocity.y += frameMoveSpeed;
            }

            // only shoot in one direction at a time, so we use if else
            if (GAME.Keyboard.keyIsDown("left_arrow") || GAME.Keyboard.keyIsDown("j")) {
                this.shoot(VECTOR.LEFT);
            }
            else if (GAME.Keyboard.keyIsDown("right_arrow") || GAME.Keyboard.keyIsDown("l")) {
                this.shoot(VECTOR.RIGHT);
            }
            else if (GAME.Keyboard.keyIsDown("up_arrow") || GAME.Keyboard.keyIsDown("i")) {
                this.shoot(VECTOR.UP);
            }
            else if (GAME.Keyboard.keyIsDown("down_arrow") || GAME.Keyboard.keyIsDown("k")) {
                this.shoot(VECTOR.DOWN);
            }
		
            this.velocity = VECTOR.multiplyScalar(this.velocity, (GAME.elapsedTime / 1000));
            this.position = VECTOR.add(this.position, this.velocity);
        }

        this.shoot = function(direction) {
            if(! isShooting){
                lastShotTime = +(new Date());
                isShooting = true;
                // spawn a bullet with the direction 
                GAME.bullets.push(new Bullet({direction:direction, position: this.position}));
                var shootAudio = RESOURCES.get('player1Shoot');
                shootAudio.load();
                shootAudio.volume = 0.3;
                shootAudio.play();

            }
            else {
                lastShotElapsedTime += GAME.elapsedTime;
                if(lastShotElapsedTime > shootInterval){
                    isShooting = false;
                    lastShotElapsedTime = 0.0;
                }
            }
        }
        
        // Calculate percentage of run bar to show
        this.runBar = function() {
          
          var runBar = {};
          
          // Run bar color
          runBar.containerColor = "rgb(24, 24, 24)";
          runBar.color = "rgb(24, 240, 204)";
          
          // Run bar coordinates
          runBar.x = 25;
          runBar.y = 30;
          //runBar.w = 100;
          runBar.h = 10;
          
          // If sprinting, decrease the bar
          if(isSprinting){
            runBarPercent = 100 - parseInt((sprintElapsedTime / sprintTime) * 100);
          }
          
          // ElseIf not sprinting, but still within sprintTime
          else if(nonSprintElapsedTime + sprintLength < sprintTime && lastSprintTime > 0){
            runBarPercent = 100 - (parseInt(((nonSprintElapsedTime + sprintLength) / sprintTime) * 100));
          }
          
          // Elseif not sprinting, 
          else if(nonSprintElapsedTime > 0 && nonSprintElapsedTime < sprintInterval && lastSprintTime > 0){
            runBarPercent = parseInt((nonSprintElapsedTime / sprintInterval) * 100);
          }
          
          
          runBar.w = runBarPercent
          
          // Display Run bar container
          GAME.renderingContext.fillStyle = runBar.containerColor;
          GAME.renderingContext.fillRect(runBar.x-1,runBar.y-1,102,runBar.h+2); 
          
          // Display Run bar
          GAME.renderingContext.fillStyle = runBar.color;
          GAME.renderingContext.fillRect(runBar.x,runBar.y,runBar.w,runBar.h); 
          
        }

        this.draw = function (rc) {
            var r = this.toRect();
            rc.save();
            var image = this.sprite.render();
            rc.drawImage(image, r.x, r.y, r.w, r.h);
            //rc.fillStyle = "rgb(255, 0, 255)";
            //rc.fillRect(r.x, r.y, r.w, r.h);
            rc.restore();
        }
    }// end of player


   
	
    GAME = (function () {


        var startTime = 0.0;

        var game = {};
        

        game.width = gameConfig.settings.width;
        game.height =gameConfig.settings.height;

        var _renderingContext = null;
        game.Keyboard = new KeyboardHandler();
   	 
        //game.selectedPlayer = 0;
   	
       

        Object.defineProperty(game, "renderingContext", {
            set: function (e) {

                var temp = _renderingContext;
                _renderingContext = e.getContext("2d");
                _renderingContext.canvas = temp;
                game.rc = _renderingContext;
            },
            get: function () {
                return _renderingContext;
            }
        });

        game.states = {};
		game.selectedPlayer = 'player1';
		game.currentLevel = 1;
        game.states.PLAYING = 1;
        game.states.GAMEOVER = 2;
        game.states.LOADING = 3;
        game.quadrants = [];
        game.enemyCnt = 0;
        game.state = game.states.LOADING;
        
        game.init = function() {
   		    
//            setupQuadrants();

            game.player = new Player({x: gameConfig.resources.characters[game.selectedPlayer].spawn.x, y: gameConfig.resources.characters[game.selectedPlayer].spawn.y, w: gameConfig.resources.characters[game.selectedPlayer].sprite.w, h: gameConfig.resources.characters[game.selectedPlayer].sprite.h,selectedPlayer:game.selectedPlayer});
            game.time = +(new Date());
            game.totalTime = 0;
            game.score = 0;
            game.state = game.states.PLAYING;
            game.enemies = new List();
            game.bullets = new List();
            game.enemyCnt = 0;
            game.states.gameoverPlayed  = false;
        }
 	 
        game.loadedResources = 0;
        game.totalResources = 6;

        game.resourcesLoaded = function(){ return game.loadedResources == game.totalResources; }

        game.run = function () {
            game.previousTime = game.time;
            game.time = +(new Date());
            game.elapsedTime = game.time - game.previousTime;
            game.totalTime += game.elapsedTime;


            switch(game.state)
            {
                case game.states.LOADING:
               	 
                    var loadingText = "LOADING";
                    var loadingLen = _renderingContext.measureText(loadingText);
                    _renderingContext.save();
                    _renderingContext.fillStyle = "rgb(255, 255, 255)";
                    _renderingContext.fillText(loadingText, game.width/2 - loadingLen.width/2, 290);
                    _renderingContext.restore();
                
                    if (RESOURCES.isLoaded()) {
						
						 var screenImage = RESOURCES.get(gameConfig.resources.screens['welcome'].name);
                    	_renderingContext.drawImage(screenImage, 0, 0, 800, 600);
						
						 if(GAME.Keyboard.keyPressed("enter")){
							game.state = game.states.PLAYING; 
                        	game.init();
   			 
                    	}
						
                        
                       // game.init();
                    }

                    break;

                case game.states.PLAYING:
                    var levelImage = RESOURCES.get(gameConfig.resources.levels[GAME.currentLevel].name);
                    _renderingContext.drawImage(levelImage, 0, 0, 800, 600);

                    game.update();
                    game.draw();

                    if(GAME.Keyboard.keyPressed("escape")){
                        game.state = game.states.GAMEOVER; 
                    }
                    break;
                case game.states.GAMEOVER:

                     var screenImage = RESOURCES.get(gameConfig.resources.screens['gameover'].name);
                      _renderingContext.drawImage(screenImage, 0, 0, 800, 600);

                      var scoreText = "SCORE: " + game.score;
                      if (!game.states.gameoverPlayed) {
                         game.states.gameoverPlayed = true;
                          game.overAudio = RESOURCES.get('gameOverAudio');
                		  game.overAudio.volume = 0.2;
                
                          game.overAudio.play();
                      }

                     _renderingContext.font = '40pt Calibri';
                     _renderingContext.fillStyle = 'red';
                     _renderingContext.fillText(scoreText, 368, 229);

                    _renderingContext.font = '20pt Calibri';
                    _renderingContext.fillStyle = 'white';
                    _renderingContext.fillText('Loser, hit [enter] to try again', 340, 350);
                        
                         if(GAME.Keyboard.keyPressed("enter")){
                            game.state = game.states.PLAYING;
                            
                            game.init();
             
                        }

                    break;
            }

            game.Keyboard.cleaner();
            requestAnimFrame(game.run);
        }

        game.update = function () {
            game.score = game.totalTime +(game.player.zombiesKilled*1000);
   		   
            var scoreText = "SCORE: " + game.score;
            var scoreLen = _renderingContext.measureText(scoreText);
            _renderingContext.font = '14pt Calibri';
            _renderingContext.fillStyle = "rgb(255, 255, 255)";
            _renderingContext.fillText(scoreText, 25, 20);
   			
            game.player.update();

			if (RandomInt(game.totalTime) < game.totalTime * 0.09 ) {
                game.enemyCnt++;
                if (game.enemyCnt == 40) {
                    enemyType = 'enemy2'
                    game.enemyCnt = 0;
                } else {
                    enemyType = 'enemy1'
                }

                game.enemies.push(new Enemy({name:enemyType,w:gameConfig.resources.characters[enemyType].sprite.w,h:gameConfig.resources.characters[enemyType].sprite.h}));
            }

            var bulletsIter = game.bullets.getIterator();

            while(bulletsIter.next()){
                var enemiesIter = game.enemies.getIterator();
                var bullet = bulletsIter.value;

                // bullet is off the screen...
                if(!bullet.update()){
                    bullet.remove();
                }

                while(enemiesIter.next()){
                    var enemy = enemiesIter.value;

                    if(collideRect(bullet.toRect(), enemy.toRect())){
                        enemiesIter.remove();
                        bulletsIter.remove();
                    }
                }
            }

            var enemiesIter = game.enemies.getIterator();
            while(enemiesIter.next()){
                if(!enemiesIter.value.update())
                    enemiesIter.remove();
            }
        }


        game.draw = function () {
            game.player.draw(_renderingContext);

            var enemiesIter = game.enemies.getIterator();

            while(enemiesIter.next()){

                var enemy = enemiesIter.value;
                enemy.draw(_renderingContext);
            }

            var bulletsIter = game.bullets.getIterator();

            while(bulletsIter.next()){
                var bullet = bulletsIter.value;
                bullet.draw(_renderingContext);
            }
        }

        return game;

    })();


    window.onload = function () {
        GAME.renderingContext = document.getElementById("canvas");
        RESOURCES.markResource(gameConfig.resources.levels['1'].name, "./resources/"+gameConfig.resources.levels['1'].src, RESOURCES.TYPES.IMAGE);
        RESOURCES.markResource(gameConfig.resources.characters['player1'].name, "./resources/"+gameConfig.resources.characters['player1'].sprite.src, RESOURCES.TYPES.IMAGE);
		RESOURCES.markResource(gameConfig.resources.characters['enemy1'].name, "./resources/"+gameConfig.resources.characters['enemy1'].sprite.src, RESOURCES.TYPES.IMAGE);
        RESOURCES.markResource(gameConfig.resources.characters['enemy2'].name, "./resources/"+gameConfig.resources.characters['enemy2'].sprite.src, RESOURCES.TYPES.IMAGE);
		RESOURCES.markResource(gameConfig.resources.screens['welcome'].name, "./resources/"+gameConfig.resources.screens['welcome'].src, RESOURCES.TYPES.IMAGE);
		RESOURCES.markResource(gameConfig.resources.screens['gameover'].name, "./resources/"+gameConfig.resources.screens['gameover'].src, RESOURCES.TYPES.IMAGE);
        RESOURCES.markResource('gameOverAudio', "./resources/"+gameConfig.resources.gameFx['gameover'], RESOURCES.TYPES.AUDIO);
        RESOURCES.markResource('enemy1Spawn', "./resources/"+gameConfig.resources.characters['enemy1'].fx['spawn'], RESOURCES.TYPES.AUDIO);
        RESOURCES.markResource('enemy2Spawn', "./resources/"+gameConfig.resources.characters['enemy2'].fx['spawn'], RESOURCES.TYPES.AUDIO);
        RESOURCES.markResource('player1Shoot', "./resources/"+gameConfig.resources.characters['player1'].fx['shoot'], RESOURCES.TYPES.AUDIO);

        GAME.run();
        GODMODE = true;

    }
</script>
</head>

<body>
<canvas id="canvas" width="800px" height="600px"></canvas>
    <img id="debug" />
</body>
</html>










