<!doctype html>
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
    <title></title>
<style>
canvas{ background-color:black; }
</style>

    <script src="keyboard.js"></script>
    <script src="tools.js"></script>

<script>
	
	var gameConfig = {
		"settings": {
			"title":"Stupid Zombies",
			"width":800,
			"height":600,	

		},
		"resources": {
            "gameFx" : {


                "die" : ""

            },
			"characters": {
				"player1":{
					"name": "Phillip",
					"src": "player1Sprite.png",
					"type":"Player"	
				},
				"player2":{
					"name": "Jorge",
					"src": "player2Sprite.png",
					"type":"Player",
					"fx": {}


				},
				"enemy1":{
					"name": "Office Zombie",
					"src": "zombieSprite.png",
					"type":"Enemy",
                    "fx" : {
                        "spawn": "zombieRising.ogg"
                    }	

				},
				"enemy2": {
					"name": "Boss Zombie",
					"src": "zombie2Sprite.png",
					"type":"Enemy"	
				}
			},
			"levels": {
				"1" :{
					"name":"Swamp",
					"src":"swamp.jpg"	
				}
			},
			"screens": {
				
				"welcome": {
					"name":"Welcome",
					"src":"welcome.jpg"	
				},
				"gameover": {
					"name":"Game Over",
					"src":"gameover.jpg"	
					
				}	
			}
		}
	}
	
    VECTOR = (function(){
        var vector = {};

        vector.Vector = function(x, y, z){
            this.x = x || 0;
            this.y = y || 0;
            this.z = z || 0;
		
            // .magnitude
            Object.defineProperty(this, "magnitude", {
                get: function(){
                    return (Math.sqrt(this.x*this.y + this.y*this.y));
                }
            });
        }


        vector.UP    = new vector.Vector( 0, -1);
        vector.DOWN  = new vector.Vector( 0,  1);
        vector.LEFT  = new vector.Vector(-1,  0);
        vector.RIGHT = new vector.Vector( 1,  0);

        vector.add = function(a, b){
            return (new vector.Vector(a.x+b.x, a.y+b.y, a.z+b.z));
        }

        vector.subtract = function(a, b){
            return (new vector.Vector(a.x-b.x, a.y-b.y, a.z-b.z));
        }

        vector.unit = function(v){
            //TODO: set dirty flag on vector to minimize sqrt calls
            var magnitude = v.magnitude;
            return (new vector.Vector(v.x / v.magnitude, v.y / v.magnitude));
        }

        vector.multiplyScalar = function(v, scalar){
            return (new vector.Vector(v.x*scalar, v.y*scalar, v.z*scalar));
        }

        return vector;
    })();
 
    RESOURCES = (function(){
        var resources = {};

        var resourcesCount = 0,
            resourcesLoaded = 0,
            resourcesAreLoaded = false,
            resourceCache = {};

        resources.TYPES = {};
        resources.TYPES.AUDIO = 1;
        resources.TYPES.IMAGE = 2;

        function onResourceLoaded(event){
            resourcesLoaded += 1;
            console.log("LOADED: ", event);
        }

        resources.isLoaded = function(){
            if(resourcesCount == resourcesLoaded){
                resourcesAreLoaded = true;
            }
            return resourcesAreLoaded;
        }

        resources.markResource = function(resourceKey, resourcePath, resourceType){
            var object = null;

            switch(resourceType){
                case resources.TYPES.IMAGE: 
                    resourcesCount += 1;
                    object = new Image();
                    object.src = resourcePath;
                    resourceCache[resourceKey] = object;
                    object.onload = onResourceLoaded;

                    break;
                case resources.TYPES.AUDIO:
                    resourcesCount += 1;
                    object = new Audio();
                    object.preload = true;
                    
                    resourceCache[resourceKey] = object;
                    object.addEventListener("onload", onResourceLoaded, false);
                    object.onloadeddata = onResourceLoaded;
                    object.src = resourcePath;
                    object.load();
                    o = object;
                    break;
            }
        }

        resources.get = function(resourceKey){
            if(!resourcesAreLoaded)
                throw "Resources aren't loaded yet :(";

            return resourceCache[resourceKey];
        }

        return resources;
    })();

    function Sprite(args){
        if(args == undefined) args = {}

        this.frameWidth = args.frameWidth || -1;
        this.frameHeight = args.frameHeight || -1;
        this.image = args.image || null;
        this.frameTime = args.frameTime || -1; //1000/60 * 4;

        // error handling => didnt pass in frame width and height and image
        if(this.frameWidth < 0) {
            // Some error
        }
        if(this.frameHeight < 0) {
            // Some error
        }
        if(this.frameTime < 0) {
            // Some error
        }
        if(!this.image) {
            // Some error
        }
        //console.log(args);
        this.imageWidth = this.image.width;
        this.imageHeight = this.image.height;

        this.framesCount = this.imageWidth / this.frameWidth;
        this.currentFrame = 0;
		//console.log('TOTAL FRAMES = '+ this.framesCount);
        this.currentFrameTime = 0;
        this.currentFrameElapsedTime = 0;
        this.currentFrameImage = document.createElement("canvas");
        this.currentFrameContext = this.currentFrameImage.getContext("2d");
        this.currentFrameImage.width = this.frameWidth;
        this.currentFrameImage.height = this.frameHeight;

        this.render = function(){
            this.currentFrameContext.clearRect(0, 0, this.frameWidth, this.frameHeight);
            this.currentFrameContext.drawImage(this.image, this.frameWidth*this.currentFrame, 0, this.frameWidth, this.frameHeight, 0, 0, this.frameWidth, this.frameHeight);
		
            if(this.currentFrameElapsedTime < this.frameTime){
                this.currentFrameElapsedTime += GAME.elapsedTime;
            }
            else {
                this.currentFrame = (this.currentFrame + 1) % this.framesCount;
                this.currentFrameElapsedTime = (this.currentFrameElapsedTime - this.frameTime);
            }

            return this.currentFrameImage;
        }
    }



    function Entity(args){
        if(args == undefined) args = {};

        var x = args.x || 0;
        var y = args.y || 0;
        var w = args.w || 1;
        var h = args.h || 1;

        this.position = new VECTOR.Vector(x, y);
        this.size = new VECTOR.Vector(w, h);
        this.velocity = new VECTOR.Vector();

        this.image = null;

        this.update = function (elapsedTime) { throw "NOT IMPLEMENTED"; };
        this.draw = function (renderContext) { throw "NOT IMPLEMENTED"; };

        this.toRect = function () {
            var hw = this.size.x / 2;
            var hh = this.size.y / 2;
            return (new Rect(this.position.x - hw, this.position.y - hh, this.size.x, this.size.y));
        }
    }
	
	function Enemy(args) {
             if(args == undefined) args = {};
       		 InheritFrom(this, Entity, args);
			this.image = RESOURCES.get(gameConfig.resources.characters[args.name].name);
			this.sprite = new Sprite({ image: this.image, frameTime: (1000/60 * 8), frameHeight: 70, frameWidth: 70});
			console.log('enemy1Spawn');
            var spawnAudio = RESOURCES.get('enemy1Spawn');
            
            spawnAudio.play();

			var moveSpeed = 150;
			
			var rand = RandomInt(3);
      	
            switch (rand) {
                // Top
                case 0:
                    this.position.x = RandomInt(GAME.width);
                    this.position.y = 0;
                    this.velocity.y = 100 + RandomInt(100);
                    break;
                    // Left
                case 1:
                    this.position.x = 0;
                    this.position.y = RandomInt(GAME.height);
                    this.velocity.x = 100 + RandomInt(100);
                    break;
                    // Bottom
                case 2:
                    this.position.x = RandomInt(GAME.width);
                    this.position.y = GAME.height;
                    this.velocity.y = -100 - RandomInt(100);
                    break;
                    // Right
                case 3:
                    this.position.x = GAME.width;
                    this.position.y = RandomInt(GAME.height);
                    this.velocity.x = -100 - RandomInt(100);
                    break;

            } // end switch

            this.draw = function (rc) {
                var r = this.toRect();
				rc.save();
           	 	var image = this.sprite.render();
				rc.drawImage(image, r.x, r.y, r.w, r.h);
				rc.restore();
            }

            this.update = function () {
              	
                var moveSpeed = VECTOR.multiplyScalar(this.velocity, (GAME.elapsedTime / 1000));

                //var moveSpeedx = this.velocity.x * (GAME.elapsedTime / 1000);
                //var moveSpeedy = this.velocity.y * (GAME.elapsedTime / 1000);

                this.position = VECTOR.add(this.position, moveSpeed);

                //this.position.x += moveSpeedx;
                //this.position.y += moveSpeedy;


                if (this.position.x < 0 || this.position.x > GAME.width ||
                    this.position.y < 0 || this.position.y > GAME.height)
                    return false;

                return true;
            }
    }


    function Bullet(args) {
            if(args == undefined) args = {};
            InheritFrom(this, Entity, args);

            this.velocity.x = args.direction.x;
            this.velocity.y = args.direction.y;

            var bulletSpeed = 500;

            this.velocity.x = this.velocity.x * bulletSpeed;
            this.velocity.y = this.velocity.y * bulletSpeed;

            this.position.x = GAME.player.position.x;
            this.position.y = GAME.player.position.y;
           
            console.log('PLAYER POSITION ' + GAME.player.position.x);

            this.bullet = new Rect(GAME.player.position.x,GAME.player.position.y,3,25);
           
            this.draw = function (rc) {

                console.log(this.bullet);
                rc.save();
                rc.fillStyle = "rgb(0, 0, 255)";
                rc.fillRect(this.position.x, this.position.y, this.bullet.w, this.bullet.h);
                

                rc.restore();
            }

            this.update = function () {
                
                var moveSpeed = VECTOR.multiplyScalar(this.velocity, (GAME.elapsedTime / 1000));


                console.log(this.velocity);
                console.log(this.position);

                this.bullet.x += moveSpeed;  
                this.bullet.y += moveSpeed;  


                return true;
            }
    }
	
	
    function Player(args){
        if(args == undefined) args = {};
        InheritFrom(this, Entity, args);
        //console.log(args);
        this.image = RESOURCES.get(args.selectedPlayer);
        
        this.sprite = new Sprite({ image: this.image, frameTime: (1000/60 * 8), frameHeight: 101, frameWidth: 41});


        var moveSpeed = 150, // pixels/second
            sprintSpeed = 300,
            isSprinting = false,
            sprintInterval = 2000, 
            sprintTime = 500,
            lastSprintTime = -1,
            sprintElapsedTime = 0,
            nonSprintElapsedTime = 0;

        var isShooting = false,
            shootInterval = 200, // in milliseconds
            shootDirection = null,
            lastShotTime = -1,
            lastShotElapsedTime = -1;

            this.zombiesKilled = 0;
      
        this.update = function(){

            var frameMoveSpeed = moveSpeed;

            if (GAME.Keyboard.keyIsDown("shift")) {
                if(! isSprinting){
                    nonSprintElapsedTime += GAME.elapsedTime;

                    if(nonSprintElapsedTime > sprintInterval){
                        frameMoveSpeed = sprintSpeed;
                        isSprinting = true;
                        lastSprintTime = +(new Date());
                        nonSprintElapsedTime = 0;
                    }
                }
                else{
                    sprintElapsedTime += GAME.elapsedTime;
                    if(sprintElapsedTime > sprintTime){
                        isSprinting = false;
                        sprintElapsedTime = 0;
                    }
                    else{
                        frameMoveSpeed = sprintSpeed;
                    }
                }
            }
            else { 
                // Not sprinting
                isSprinting = false;
                sprintElapsedTime = 0;
                nonSprintElapsedTime += GAME.elapsedTime;
            } 

            // Update character movement

            if (GAME.Keyboard.keyIsDown("a")) {
                this.velocity.x -= frameMoveSpeed;
            }

            if (GAME.Keyboard.keyIsDown("d")) {
                this.velocity.x += frameMoveSpeed;

            }

            if (GAME.Keyboard.keyIsDown("w")) {
                this.velocity.y -= frameMoveSpeed;
            }

            if (GAME.Keyboard.keyIsDown("s")) {
                this.velocity.y += frameMoveSpeed;
            }

            if (GAME.Keyboard.keyIsDown("left_arrow")) {
                this.shoot(VECTOR.LEFT);
            }
            if (GAME.Keyboard.keyIsDown("right_arrow")) {
                this.shoot(VECTOR.RIGHT);
            }
            if (GAME.Keyboard.keyIsDown("up_arrow")) {
                this.shoot(VECTOR.UP);
            }
            if (GAME.Keyboard.keyIsDown("down_arrow")) {
                this.shoot(VECTOR.DOWN);
            }
		
            this.velocity = VECTOR.multiplyScalar(this.velocity, (GAME.elapsedTime / 1000));
            this.position = VECTOR.add(this.position, this.velocity);
        }

        this.shoot = function(direction) {
            if(! isShooting){
                lastShotTime = +(new Date());
                isShooting = true;
                console.log('DIRECTION');
                console.log(direction)
                // spawn a bullet with the direction 
                GAME.bullets.push(new Bullet({direction:direction}));

            }
            else {
                lastShotElapsedTime += GAME.elapsedTime;
                if(lastShotElapsedTime > shootInterval){
                    isShooting = false;
                    lastShotElapsedTime = 0.0;
                }
            }
        }


        this.draw = function (rc) {
            var r = this.toRect();
            rc.save();
            var image = this.sprite.render();
            rc.drawImage(image, r.x, r.y, r.w, r.h);
            //rc.fillStyle = "rgb(255, 0, 255)";
            //rc.fillRect(r.x, r.y, r.w, r.h);
            rc.restore();
        }
    }// end of player


   
	
    GAME = (function () {


        var startTime = 0.0;

        var game = {};
        

        game.width = gameConfig.settings.width;
        game.height =gameConfig.settings.height;

        var _renderingContext = null;
        game.Keyboard = new KeyboardHandler();
   	 
        //game.selectedPlayer = 0;
   	
       

        Object.defineProperty(game, "renderingContext", {
            set: function (e) {

                var temp = _renderingContext;
                _renderingContext = e.getContext("2d");
                _renderingContext.canvas = temp;
                game.rc = _renderingContext;
            },
            get: function () {
                return _renderingContext;
            }
        });

        game.states = {};
		game.selectedPlayer = gameConfig.resources.characters['player1'].name;
		game.currentLevel = 1;
        game.states.PLAYING = 1;
        game.states.GAMEOVER = 2;
        game.states.LOADING = 3;
        game.state = game.states.LOADING;
    
        game.init = function() {
   		       
            game.player = new Player({x: 100, y: 200, w: 41, h: 101,selectedPlayer:game.selectedPlayer});
            game.time = +(new Date());
            game.totalTime = 0;
            game.score = 0;
            game.state = game.states.PLAYING;
            enemies = [];
            game.bullets = [];
        }
 	 
        game.loadedResources = 0;
        game.totalResources = 6;

        game.resourcesLoaded = function(){ return game.loadedResources == game.totalResources; }

        game.run = function () {
            game.previousTime = game.time;
            game.time = +(new Date());
            game.elapsedTime = game.time - game.previousTime;
            game.totalTime += game.elapsedTime;


            switch(game.state)
            {
                case game.states.LOADING:
               	 
                    var loadingText = "LOADING";
                    var loadingLen = _renderingContext.measureText(loadingText);
                    _renderingContext.save();
                    _renderingContext.fillStyle = "rgb(255, 255, 255)";
                    _renderingContext.fillText(loadingText, game.width/2 - loadingLen.width/2, 290);
                    _renderingContext.restore();
                
                    if (RESOURCES.isLoaded()) {
						
						 var screenImage = RESOURCES.get(gameConfig.resources.screens['welcome'].name);
                    	_renderingContext.drawImage(screenImage, 0, 0, 800, 600);
						
						 if(GAME.Keyboard.keyPressed("enter")){
							game.state = game.states.PLAYING; 
                        	game.init();
   			 
                    	}
						
                        
                       // game.init();
                    }

                    break;

                case game.states.PLAYING:
                    var levelImage = RESOURCES.get(gameConfig.resources.levels[GAME.currentLevel].name);
                    _renderingContext.drawImage(levelImage, 0, 0, 800, 600);

                    game.update();
                    game.draw();
                    break;
                case game.states.GAMEOVER:

                     var screenImage = RESOURCES.get(gameConfig.resources.screens['gameover'].name);
                      _renderingContext.drawImage(screenImage, 0, 0, 800, 600);

                      var scoreText = "SCORE: " + game.score;
                   
                     _renderingContext.font = '40pt Calibri';
                     _renderingContext.fillStyle = 'red';
                     _renderingContext.fillText(scoreText, 368, 229);

                    _renderingContext.font = '20pt Calibri';
                    _renderingContext.fillStyle = 'white';
                    _renderingContext.fillText('Loser, hit [enter] to try again', 340, 350);
                        
                         if(GAME.Keyboard.keyPressed("enter")){
                            game.state = game.states.PLAYING; 
                            game.init();
             
                        }

                    break;
            }

            game.Keyboard.cleaner();
            requestAnimFrame(game.run);
        }

        game.update = function () {
            game.score = game.totalTime +(game.player.zombiesKilled*1000);
   		   
            var scoreText = "SCORE: " + game.score;
            var scoreLen = _renderingContext.measureText(scoreText);
            _renderingContext.font = '14pt Calibri';
            _renderingContext.fillStyle = "rgb(255, 255, 255)";
            _renderingContext.fillText(scoreText, 25, 20);
   			
            game.player.update();

			if (RandomInt(game.totalTime) < game.totalTime * 0.10 ) {

                if (enemies.length < 10) 
                    enemies.push(new Enemy({name:'enemy1',w:70,h:70})); 

            }

            for (var i = 0; i < game.bullets.length; ++i) {
                 if (!game.bullets[i].update()){
                    // If the enemy is off the screen
                    game.bullets.splice(i, 1);
                }
            }
            
            for (var i = 0; i < enemies.length; ++i){
           
                // Check if player and enemy collided
                
                if (collideRect(game.player.toRect(), enemies[i].toRect()))
                    game.state = game.states.GAMEOVER;

                if (!enemies[i].update()){
                    // If the enemy is off the screen
                    enemies.splice(i, 1);
                }


            }
			
			
   		 	
        }

        game.draw = function () {
            game.player.draw(_renderingContext);

            for (var i = 0; i < enemies.length; ++i)
                enemies[i].draw(_renderingContext);

             for (var i = 0; i < game.bullets.length; ++i)
                game.bullets[i].draw(_renderingContext);
            
        }
        return game;

    })();


    window.onload = function () {
        GAME.renderingContext = document.getElementById("canvas");
        RESOURCES.markResource(gameConfig.resources.levels['1'].name, "./"+gameConfig.resources.levels['1'].src, RESOURCES.TYPES.IMAGE);
        RESOURCES.markResource(gameConfig.resources.characters['player1'].name, "./"+gameConfig.resources.characters['player1'].src, RESOURCES.TYPES.IMAGE);
		RESOURCES.markResource(gameConfig.resources.characters['enemy1'].name, "./"+gameConfig.resources.characters['enemy1'].src, RESOURCES.TYPES.IMAGE);
		RESOURCES.markResource(gameConfig.resources.screens['welcome'].name, "./"+gameConfig.resources.screens['welcome'].src, RESOURCES.TYPES.IMAGE);
		RESOURCES.markResource(gameConfig.resources.screens['gameover'].name, "./"+gameConfig.resources.screens['gameover'].src, RESOURCES.TYPES.IMAGE);
        RESOURCES.markResource('enemy1Spawn', "./"+gameConfig.resources.characters['enemy1'].fx['spawn'], RESOURCES.TYPES.AUDIO);

        GAME.run();

    }
</script>
</head>

<body>
<canvas id="canvas" width="800px" height="600px"></canvas>
    <img id="debug" />
</body>
</html>










